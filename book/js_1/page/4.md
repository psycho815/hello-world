#变量、作用域和内存问题

1. [基本类型值和引用类型值](#a1)
2. [执行环境及作用域](#a2)
3. [垃圾收集](#a3)
4. [小结](#a4)

<h3 id="a1">1、基本类型值和引用类型值</h3>
javascript变量包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据字段，而引用类型值指那些可能由多个值构成的对象。

5种基本数据类型：（Undefined，Null，Boolean，Number，String）是按值访问的，因为可以操作保存在变量中的实际的值。

引用类型的值是保存在内存中的对象。javascript不能直接访问内存中的位置，也就是不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的。

注：在很多语言中，字符串以对象的形式来表示，因此被认为是引用类型的。javascript放弃了这一传统。

1）动态的属性

我们可以为引用类型添加属性，并访问这个新属性，但是不能给基本类型的值添加属性。

    var person=new Object();
    person.name="Nicholas";
    alert(person.name);  //"Nicholas"
    //not
    var name="Nicholas";
    name.age=27;
    alert(name.age); //undefined
    //    只能给引用类型值动态地添加属性，以便将来使用

2）复制变量值

除了保存方式不同，在从一个变量向另一个变量复制基本类型值和引用类型值时，也存在不同。

    var num1 = 5;
    var num2 = num1;
    alert(num2);  //5
    //    如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。
    //    num2中的5与num1中的5是完全独立的。这两个变量可以参与任何操作而不会相互影响。
    var obj1=new Object();
    var obj2=obj1;
    obj1.name="Nicholas";
    alert(obj2.name);  //"Nicholas"
    //    当一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新的变量分配的空间中。不同的是，这个值的副本
    //    实际上是一个指针，而这个指针指向存储在堆中的一个对象。两个变量实际将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量。

3）传递参数

javascript中所有函数的参数都是按值传递的。基本类型值的传递如同基本类型变量的复制一样，引用类型值的传递如同引用类型变量的复制一样。

在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者用javascript的概念来说，就是arguments对象中的一个元素）。

在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。


        //    基本类型
        function addTen(num) {
            num += 10;
            return num;
        }
        var count = 20;
        var result = addTen(count);
        alert(count); //20
        alert(result); //30
        //    引用类型
        function setName(obj) {
            obj.name = "Nicholas";
        }
        var person = new Object();
        person.name = "Greg";
        alert(person.name); //"Greg"
        setName(person);
        alert(person.name); //"Nicholas"
    //    在函数内部，obj和person引用的是同一个对象。
    //    很多开发人员错误的认为：在局部作用域中修改的对象会在全局作用域中反映出来，就说明参数是按引用传递的，
    // 为了证明对象是按值传递的，对比：
        function setName1(obj){
            obj.name="Nicholas";
            obj=new Object();
            obj.name="Greg";
        }
        var person1=new Object();
        setName1(person1);
        alert(person1.name); //Nicholas
    //    当在函数内部重写obj时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。

注意：可以把javascript函数的参数想象成局部变量。

4）检测类型

当要检测一个变量是不是基本数据类型时，使用typeof操作符是最佳的工具。

    //    typeof操作符
    //    var s = "Nicholas";
    //    var b = true;
    //    var i = 22;
    //    var u;
    //    var n = null;
    //    var o = new Object();
    //    alert(typeof s); //string
    //    alert(typeof b); //boolean
    //    alert(typeof i); //number
    //    alert(typeof u); //undefined
    //    alert(typeof n); //object
    //    alert(typeof o); //object
        //    当我们并不是想知道某个值是对象，而是想知道它是什么类型的对象。使用：
        //    instanceof 操作符
        var person = new Object();
        var array = new Array();
        var pattern = new RegExp();
        alert(person instanceof Object); //true
        alert(array instanceof Array); //true
        alert(array instanceof Object); //true .所有引用类型的值都是Object的实例，因此在检测一个引用类型值和Object构造函数时，
    //    instanceof操作符始终会返还true
        alert(pattern instanceof RegExp); //true
使用typeof操作符检测函数时，该操作符会返回“function”。

在ie和firefox中，对正则表达式应用typeof会返回“object“

<h3 id="a2">2、执行环境及作用域</h3>
执行环境定义了变量或函数有权访问的其他数据，决定了了它们各自的行为。

全局执行环境是最外围的一个执行环境。在web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保持在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出——例如关闭网页或浏览器时才会被销毁）。

当代码在一个环境中执行时，会创建变量对象的一个**作用域链**。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量的对象。活动对象在最开始只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。

标识符的解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直到找到标识符为止（如果找不到标识符，通常会导致错误发生），示例：

    //    var color = "blue";
    //    function changeColor() {
    //        if (color == "blue") {
    //            color = "red";
    //        } else {
    //            color = "blue";
    //        }
    //    }
    //    changeColor();
    //    alert("Color is now " + color);  //"Color is now red"
    //    函数changeColor()的作用域链包含链各个对象：它自己的变量对象（其中定义着arguments对象）和全局环境的变量对象。
    // 可以在函数内部访问变量color，就是因为可以在这个作用域链中找到它。
    //    此外，在局部作用域中定义的变量可以在局部环境中与全局变量互换使用，如下：
        var color="blue";
        function changeColor(){
            var anotherColor="red";
            function swapColors(){
                var tempColor=anotherColor;
                anotherColor=color;
                color=tempColor;
    //            这里可以访问color，anotherColor，tempColor
            }
    //        这里可以访问color和anotherColor，但不能访问tempColor
            swapColors();
            alert(anotherColor); //"blue"
        }
    //    这里只能访问color
        changeColor();
        alert("Color is now "+color); //"Color is now red"
注意：函数参数也被当作变量来对待，因此其访问规则与其执行环境中的其它变量相同

1）延长作用域

虽然执行环境的类型总共只有两种——全局和局部（函数），但还是有其它办法来延长作用域链。这么说是因为有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。在两种情况下会发生这种现象，具体来说，就是当执行流进入下列任何一个语句时，作用域链就会得到加长：

- try-catch语句的catch块；
- with语句。

'

    function buildUrl() {
        var qs = "?debug=true";
        with (location) {
            var url = href + qs;
        }
        return url;
    }
    alert(buildUrl()); //"http://localhost:63342/MYIDEA/index.html?debug=true"

2）没有块级作用域

在其他类C的语言中，有花括号封闭的代码块都有自己的作用域（如果用javascript的话来讲，就是它们自己的执行环境）。但是，javascript没有块级作用域。


        if(true){
            var color="blue";
        }
        alert(color); //"blue"
    //    if语句中的变量声明会将变量添加到当前执行环境（在这里是全局环境）中。
        for(var i=0;i<10;i++){
    //        doSomething();
        }
        alert(i);  //10
    //    for语句创建的变量i即使在for循环执行结束后，也依旧会存在于循环外部的执行环境中。

**声明变量**

注意：在函数内部，如果初始化变量没有使用var声明，该变量会自动被添加到全局环境中。建议在初始化变量之前，一定要先声明。

**查询标识符**

当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。

如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符。

    //    例1
    //    var color = "blue";
    //    function getColor() {
    //        return color;
    //    }
    //    alert(getColor()); //"blue"
    //    例2
        var color="blue";
        function getColor(){
            var color="red";
            return color;
        }
        alert(getColor()); //"red"
    //    任何位于局部变量color的声明之后的代码，如果不使用window.color都无法访问全局变量color。
变量查询也不是没有代价的。很明显，访问局部变量要比访问全局变量更快，因为不用向上搜索作用域链。javascript引擎在优化标识符查询方面做得不错，因此这个差别在将来恐怕就可以忽略不计了。

<h3 id="a3">3、垃圾收集</h3>
 javascript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。所需内存的分配以及无用内存的回收完全实现了自动管理。

原理：找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间）周期性地执行这一操作。

确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。

 一旦数据不再有用，最好通过将其值设置为null来释放其引用——这个做法叫做解除引用。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用。

不过，解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。

<h3 id="a4">小结：</h3>

javascript变量可以用来保存两种类型的值：基本类型值和引用类型值。基本类型的值源自以下5中基本数据类型：Undefined，Null，Boolean，Number和String。基本类型值和引用类型值具有以下特点：

- 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；
- 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；
- 引用类型的值是对象，保存在堆内存中；
- 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；
- 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象。
- 确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符。

所有变量（包括基本类型和引用类型）都存在于一个执行环境中（也称为作用域）当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。以下是关于执行环境的几点总结：

- 执行环境有全局执行环境（也称为全局环境）和函数执行环境之分；
- 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；
- 函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全局环境；
- 全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；
- 变量的执行环境有助于确定应该何时释放内存。

javascript是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。以对javascript的垃圾收集例程作如下总结：

- 离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除；
- ”标记清除“是目前主流的垃圾收集算法，这种算法的思想是给当前不适用的值加上标记，然后再回收其内存；
- 另一种垃圾收集算法是”引用计数“，这种算法的思想是跟踪记录所有值被引用的次数。javascript引擎目前都不再使用这种算法；但在ie中访问非原生javascript对象（如DOM元素）时，这种算法仍然可能会导致问题。
- 当代码中存在循环引用现象时，”引用计数“算法就会导致问题。
- 解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。