#函数表达式

1. [递归](#a1)
2. [闭包](#a2)
3. [模仿块级作用域](#a3)
4. [私有变量](#a4)
5. [小结](#a5)

回顾，函数声明和函数表达式的区别

能够创建匿名函数赋值给变量，也就能够把函数作为其他函数的返回值。

<h3 id="a1">一、递归</h3>

递归函数是在一个函数通过名字调用自身的情况下构成的。

        function factorial(num) {
            if (num <= 1) {
                return 1;
            } else {
    //            return num * factorial(num - 1);  //当重置变量factorial的时候会报错
                return num * arguments.callee(num - 1);  //arguments.callee是一个指向正在在执行的函数的指针
            }
        }
        //    当在严格模式下，不能通过脚本访问 arguments.callee，访问这个属性会导致错误，可以使用命名函数表达式来达成相同效果。例如;
        var factorial1 = (function f(num) {
            if (num <= 1) {
                return 1;
            } else {
                return num * f(num - 1);
            }
        });
        var anotherFactorial = factorial;
        factorial = null;
        alert(anotherFactorial(4)); //24
<h3 id="a2">二、闭包</h3>

闭包是指有权访问另一个函数作用域中的变量的函数。

    function createComparisonFunction(propertyName) {
        return function (object1, object2) {
            var value1 = object1[propertyName];
            var value2 = object2[propertyName];
            if (value1 < value2) {
                return -1;
            } else if (value1 > value2) {
                return 1;
            } else {
                return 0;
            }
        }
    }
    var compare = createComparisonFunction("name");
    var result = compare({name: "Nicholas"}, {name: "Greg"});
    alert(result);  //1
    //在匿名函数从createComparisonFunction()中被返回后，它的作用域链被初始化为包含createComparisonFunction()函数的活动对象和全局变量对象。这样，匿名函数就
    可以访问在createComparisonFunction()中定义的所有变量。更为重要的是，createComparisonFunction()函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的
    作用域链仍然在引用这个活动对象。换句话说，当createComparisonFunction()函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中；直到匿名
    函数被销毁后，createComparisonFunction()的活动对象才会被销毁。
     //解除对匿名函数的引用（以便释放内存） 
    compare=null;
加粗那两行代码是内部函数（一个匿名函数）中的代码，这两行代码访问了外部函数中的变量propertyName。即使这个内部函数被返回了，而且是在其他地方被调用了，但它仍然可以访问变量propertyName。之所以可以访问这个变量，是因为内部函数的作用域链中包含createComparisonFunction()的作用域。

注意：由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多，建议读者只在绝对必要时再考虑使用闭包

**1、闭包与变量**

    //闭包只能取得包含函数中任何变量的最后一个值
    function createFunction1() {
    var str = new Array();
    for (var i = 0; i < 10; i++) {
    str[i] = function () {
    return i;
    }
    }
    return str;
    }
    //通过创建一个匿名函数强制让闭包的行为符合预期
    function createFunction2() {    //①
    var result = new Array();
    for (var i = 0; i < 10; i++) {
    result[i] = function (num) {   //②
    return function () {     //③
    return num;
    };
    }(i);  //立即执行
    }
    return result;
    }
    var xx1 = createFunction1();
    var xx2 = createFunction2();  //强制执行了①②并将i赋值给num；即result[0]的function里面num=0；result[1]的function里面num=1；.......
    alert(xx1[0]()); //10
    alert(xx1[9]()); //10
    alert(xx2[0]()); //0
    alert(xx2[9]()); //9

**2、关于this对象**

    //    this对象是在运行时基于函数的执行环境绑定的
    var name = "The Window";
    var object = {
        name: "My Object",
        getNameFunc: function () {
            return function () {
                return this.name;
            }
        }
    }
    alert(object.getNameFunc()()); //"The Window"
    //    解决方法：
    var object1 = {
        name: "My Object",
        getNameFunc: function () {
            var that = this;
            return function () {
                return that.name;
            }
        }
    }
    alert(object1.getNameFunc()()); //"My Object"

'

    //    在几种特殊的情况下，this的只可能会意外的改变
    var name = "The Window";
    var object = {
        name: "My Object",
        getName: function () {
            return this.name;
        }
    };
    alert(object.getName());   //"My Object"
    alert((object.getName)()); //"My Object"
    alert((object.getName = object.getName)());  //"The Window"
    //    等价于
    var other = object.getName;
    alert(other());  //"The Window"

**3、内存泄露**

<h3 id="a3">三、模仿块级作用域</h3>

if语句跟for语句中的变量声明会将变量添加到当前的执行环境中。


    function outputNumbers(count) {
        for (var i = 0; i < count; i++) {
            alert(i);
        }
        var i;  //对后续的声明视而不见（不过会执行后续声明中的变量初始化）
        alert(i); //计数
    }
    outputNumbers(2); //"0","1","2"
用作块级作用域（通常称为私有作用域）的匿名函数的语法如下：

    (function () {
        //这里是块级作用域
    })();

由以下演变而来：

    var someFunction = function () {
        //这里是块级作用域
    }
    someFunction();


    //    对比上一个示例
    function outputNumbers(count) {
    
        (function () {
            for (var i = 0; i < count; i++) {
                alert(i);
            }
        })();
        alert(i); //计数
    }
    outputNumbers(2); //"0" "1" "ReferenceError: i is not defined"
    //    把以下代码放在全局作用域中，可以用来确定哪一天是3月27日；如果到了这一天，就会向用户显示一条 祝贺消息
    (function () {
        var now = new Date();
        if (now.getMonth() == 2 && now.getDate() == 27) {
            alert("Happy new year!");
        }
    })();

<h3 id="a4">四、私有变量</h3>

私有变量包括函数的参数，局部变量和在函数内部定义的其他函数。

我们把有权访问私有变量和私有函数的方法称为特权方法。有两种在对象上创建特权方法的方式，一种是在构造函数中定义特权方法。构造函数模式的缺点是针对每个实例都会创建同样一组新方法，而另一种是使用静态私有变量来实现特权方法就可以避免这个问题。

        function MyObject() {
    //    私有变量和私有函数
            var privateVariable = 10;
    
            function privateFunction() {
                return false;
            }
    
    //    特权方法
            this.publicMethod = function () {
                privateVariable++;
                return privateFunction();
            }
        }
    
        var person = new MyObject();
        alert(person.publicMethod()); //false

**1、静态私有变量**

通过在私有作用域中定义私有变量或函数，同样也可以创建特权方法。

        (function () {
    //        私有变量和私有函数
            var privateVariable = 10;

            function privateFunction() {
                return false;
            }

    //        构造函数
            MyObject = function () {
            };
    //        构造函数之所以并不适用函数声明，而使用函数表达式。是因为函数声明只能创建局部函数，那并不是我们想要的。
    // 因为想要在私有作用域外面创建MyObject对象，在严格模式下给未经声明的变量赋值会导致错误。
    //        公有/特权方法
            MyObject.prototype.publicMethod = function () {
                privateVariable++;
                return privateFunction();
            }
        })();
        var obj = new MyObject();
        alert(obj.publicMethod()); //false
这个模式与在构造函数中定义特权方法的主要区别，就在于私有变量和函数是由实例共享的。由于特权方法是在原型上定义的，因此所有实例都使用同一个函数。而这个特权方法，作为一个闭包，总是保存着对包含作用域的引用。

    (function () {
        var name = "";
        Person = function (value) {
            name = value;
        }
        Person.prototype.getName = function () {
            return name;
        }
        Person.prototype.setName = function (value) {
            name = value;
        }
    })();
    var person1 = new Person("Nicholas");
    alert(person1.getName()); //"Nicholas"
    person1.setName("Greg");
    alert(person1.getName()); //"Greg"
    var person2 = new Person();
    alert(person2.getName() == person1.getName()); //true
以这种方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。

**2、模块模式**

前面的模式是用于为自定义类型创建私有变量和特权方法的。而道格拉斯所说的模块模式则是为单例创建私有变量和特权方法。所谓单例，指的就是只有一个实例的对象。按照惯例，javascript是以对象字面量的方式来创建单例对象的。

模块模式通过为单例添加私有方法和特权方法能够使其得到增强。

        var singleton = function () {
    //私有变量和私有函数
            var privateVariable = 10;
    
            function privateFunction() {
                return false;
            }
    
            return{
                publicProperty: true,
                publicMethod: function () {
                    privateVariable++;
                    return privateFunction();
                }
            }
        }();
        alert(singleton.publicProperty); //true
        alert(singleton.publicMethod()); //false
 这里的单例指的是singleton。

这个模块使用了一个返回对象的匿名函数。在这个匿名函数内部，首先定义了私有变量和函数。然后，将一个对象字面量作为函数的值返回。返回的对象字面量中只包含可以公开的属性和方法。由于这个对象是在匿名函数内部定义的，因此它的共有方法有权访问私有变量和函数。从本质上来讲，这个对象字面量定义的是单例的公共接口。这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的。

        var application = function () {
    //        私有变量和函数
            var components = new Array();
    //        初始化
            components.push("Nicholas", "Greg");
    //        公共
            return{
                getComponentCount: function () {
                    return components.length;
                },
                registerComponent: function (component) {
                    if (typeof component == "string") {
                        components.push(component);
                    }
                }
            };
        }();
        alert(application.getComponentCount()); //2
        application.registerComponent("zhaojie");
        alert(application.getComponentCount()); //3
**3、增强的模块模式**

 有人进一步改进了模块模式，即在返回对象之前加入对其增强的代码。这种增强的模块模式适合那些单例必须是某种类型的实例，同时还必须添加某些属性和（或）方法对其加以增强的情况。

        function CustomType() {
        }
        var singleton = function () {
    //    私有变量和私有函数
            var privateVariable = 10;
    
            function privateFunction() {
                return false;
            }
    
    //    创建对象
            var object = new CustomType();
    //    添加特权/公有属性和方法
            object.publicProperty = true;
            object.publicMethod = function () {
                privateVariable++;
                return privateFunction();
            };
    //    返回这个对象
            return object;
        }();
        alert(singleton.publicProperty); //true
        alert(singleton.publicMethod()); //true
如果前面演示模块模式的例子中的application对象必须是BaseComponent的实例，那么久可以使用以下代码。

        function BaseComponent() {
    
        }
        var application = function () {
    //    私有变量和函数
            var components = new Array();
    //    初始化
            components.push(new BaseComponent());
    //    创建application的一个局部副本
            var app = new BaseComponent();
    //    公共接口
            app.getComponentCount = function () {
                return components.length;
            }
            app.registerComponent = function (component) {
                if (typeof component == "object") {
                    components.push(component);
                }
            };
    //    返回这个副本
            return app;
        }();
        alert(application.getComponentCount()); //1
        application.registerComponent(null);
        alert(application.getComponentCount()); //2
    //这个重写后的应用程序（application）单例中，首先也是像前面例子中一样定义了私有变量。主要的不同之处在于命名变量app的创建过程，
    //因为它必须是BaseComponent的实例。这个实例实际上是spplication对象的局部变量版。然后，我们又为app对象添加了能够访问私有变量的公有方法。
    //最后一步是返回app对象，结果仍然是将它赋值给全局变量application。

<h3 id="a5">五、小结</h3>

 在javascript编程中，函数表达式是一种非常有用的技术。使用函数表达式可以无须对函数命名，从而实现动态编程。匿名函数，也称为拉姆达函数，是一种javascript函数的强大方式。以下总结了函数表达式的特定。

- 函数表达式不同于函数声明。函数声明要求有名字，但函数表达式不需要。没有名字的函数表达式也叫做匿名函数。
- 在无法确定如何引用函数的情况下，递归函数就会变得比较复杂；
- 递归函数应该始终使用arguments.callee来递归地调用自身，不要使用函数名——函数名可能会发生变化。

当在函数内部定义了其他函数时，就创建了闭包。闭包有权访问包含函数内部的所有变量，原理如下：

- 在后台执行环境中，闭包的作用域链包含着他自己的作用域、包含函数的作用域和全局作用域。
- 通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。
- 但是，当函数返回了一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止。

使用闭包可以在javascript中模仿块级作用域（javascript本身没有块级作用域的慨念），要点如下：

- 创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用。
- 结果就是函数内部的所有变量都会被立即销毁——除非将某些变量赋值给了包含作用域（即外部作用域）中的变量。

闭包还可以用于在对象中创建私有变量，相关慨念和要点如下。

- 即使javascript中没有正式的私有对象的慨念，但可以使用闭包来实现公有方法，而通过共有方法可以访问在包含作用域中定义的变量
- 有权访问私有变量的公有方法叫做特权方法
- 可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用模块模式、增强的模块模式来实现单例的特权方法。

javascript中的函数表达式和闭包都是极有用的特性，利用它们可以实现很多功能。不过，因为创建闭包必须维护额外的作用域，所以过度使用它们可能会占用大量内存。