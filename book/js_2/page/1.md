#面向对象的javascript

JavaScript 没有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象 与对象之间的继承

**1、动态类型语言和鸭子类型**

编程语言按照数据类型大体可以分为两类，一类是静态类型语言，另一类是动态类型语言。 

静态类型语言在编译时便已确定变量的类型，而动态类型语言的变量类型要到程序运行的时 候，待变量被赋予某个值之后，才会具有某种类型。 

**2、多态**

多态的实际含义是：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。

多态背后的思想是将“做什么”和“谁去做以及怎样去做”分离开来，也就是将“不变的事 物”与 “可能改变的事物”分离开来。

使用继承来得到多态效果，是让对象表现出多态性的常用手段。继承通常包括实现继承和接口继承。

JavaScript对象的多态性是与生俱来的。

多态根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而 消除这些条件分支语句。

    var googleMap = {
        show: function() {
            console.log('开始渲染谷歌地图');
        }
    };
    var baiduMap = {
        show: function() {
            console.log('开始渲染百度地图');
        }
    };
    var renderMap = function(map) {
        if (map.show instanceof Function) {
            map.show();
        }
    };
    renderMap(googleMap); // 输出：开始渲染谷歌地图  
    renderMap( baiduMap );     // 输出：开始渲染百度地图  

    // 即使以后增加了搜搜地图，renderMap 函数仍 然不需要做任何改变
    var sosoMap = {
        show: function() {
            console.log('开始渲染搜搜地图');
        }
    };
    renderMap(sosoMap); // 输出：开始渲染搜搜地图

**3、封装**

1）封装数据
JavaScript并没有提供private，public等关键字来提供不同的访问权限，而是依赖变量的作用域来实现封装特性

2）封装实现
封装不仅仅是 隐藏数据，还包括隐藏实现细节、设计细节以及隐藏对象的类型等。 
封装使得对象之间的耦合变松散，对象之间只通过暴露的 API接口来通信。比如each函数。

3）封装类型
封装类型是通过抽象类和接口 来进行的。把对象的真正类型隐藏在抽象类或者接口之后，相比对象的类型，客户更关心对象 的行为。
在 JavaScript中，并没有对抽象类和接口的支持。so,在封装类型方面，JavaScript没有能力，也没有必要做得更多。

4）封装变化
从设计模式的角度出发，封装在更重要的层面体现为封装变化。
通过封装变化的方式，把系统中稳定不变的部分和容易变化的部分隔离开来，在系统的演变 过程中，我们只需要替换那些容易变化的部分，如果这些部分是已经封装好的，替换起来也相对 
容易。这可以大程度地保证程序的稳定性和可扩展性。  

**4、原型模式和基于原型继承的 JavaScript对象系统**

1）使用克隆的原型模式
原型模式是通过克隆来创建对象的
ECMAScript 5提供了Object.create 方法，可以用来克隆对象。

    var Plane = function() {
        this.blood = 100;
        this.attackLevel = 1;
        this.defenseLevel = 1;
    };
    var plane = new Plane();
    plane.blood = 500;
    plane.attackLevel = 10;
    plane.defenseLevel = 7;
    var clonePlane = Object.create(plane);
    console.log(clonePlane); // 输出：Object {blood: 500, attackLevel: 10, defenseLevel: 7} 
    //在不支持 Object.create 方法的浏览器中，则可以使用以下代码： 
    Object.create = Object.create || function(obj) {
        var F = function() {};
        F.prototype = obj;
        return new F();
    }
2）克隆是创建对象的手段
3）体验lo语言
在 JavaScript语言中不存在类的概念，对象也并非从类中创建出来的，所有的 JavaScript对象都是从某个对象上克隆而来的。 

4）原型编程范型的一些规则
如果 A对象是从 B对象克隆而来的，那么 B对象就是 A对象的原型。
原型规范基本规则：

- 所有的数据都是对象。
- 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。 
- 对象会记住它的原型。 
- 如果对象无法响应某个请求，它会把这个请求委托给它自己的原型。 

**5、javascript中的原型继承**

JavaScript也同样遵守以上原型编程的基本规则
JavaScript中的根对象是 Object.prototype 对象。Object.prototype 对象是一个空的 对象。我们在 JavaScript 遇到的每个对象，实际上都是从 Object.prototype 对象克隆而来的， Object.prototype 对象就是它们的原型。

    function Person(name) {
        this.name = name;
    };
    Person.prototype.getName = function() {
        return this.name;
    };
    var a = new Person('sven')
    console.log(a.name); // 输出：sven 
    console.log( a.getName() );     // 输出：sven 
    console.log( Object.getPrototypeOf( a ) === Person.prototype );     // 输出：true
在这里 Person 并不是类，而是函数构造器，JavaScript的函数既可以作为普通函数被调用， 也可以作为构造器被调用。当使用 new 运算符来调用函数时，此时的函数就是一个构造器。 用 new 运算符来创建对象的过程，实际上也只是先克隆 Object.prototype 对象，再进行一些其他额 外操作的过程。

虽然 JavaScript 的对象初都是由 Object.prototype 对象克隆而来的，但对象构造 器的原型并不仅限于 Object.prototype 上，而是可以动态指向其他对象。这样一来，当对象 a 需 要借用对象 b 的能力时，可以有选择性地把对象 a 的构造器的原型指向对象 b，从而达到继承的 效果。

    var obj = {
        name: 'sven'
    };
    var A = function() {};
    A.prototype = obj;
    var a = new A();
    console.log(a.name); // 输出：sven
'

    var A = function() {};
    A.prototype = {
        name: 'sven'
    };
    var B = function() {};
    B.prototype = new A();
    var b = new B();
    console.log(b.name); // 输出：sven
**6、原型继承的未来**

通过 Object.create 来创建对象的效率并不高，通 常比通过构造函数创建对象要慢。此外还有一些值得注意的地方，比如通过设置构造器的 prototype 来实现原型继承的时候，除了根对象 Object.prototype 本身之外，任何对象都会有一个 原型。而通过 Object.create( null )可以创建出没有原型的对象。