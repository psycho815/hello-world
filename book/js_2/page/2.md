#this、call和apply
###一，this
this的指向大致分为4种：

- 作为对象的方法调用 (this指向该对象)
- 作为普通函数调用 （ this指向全局对象，即window）②
- 构造器调用 ③
- Function.prototype.call 或 Function.prototype.apply 调用（动态改变传入函数的this）

②如在 div 节点的事件函数内部，有一个局部的 callback 方法， callback 被作为普通函数调用时，callback 内部的 this 指向了 window，但我们往往是想让它指向 该 div 节点。
有一种简单的解决方案，可以用一个变量保存 div 节点的引用： 

    document.getElementById('div1').onclick = function() {
        var that = this; // 保存 div 的引用     
        var callback = function() {
            alert(that.id); // 输出：'div1'     
        }
        callback();
    };

③当用 new 运算符调用函数时，该函数总 会返回一个对象，通常情况下，构造器里的 this 就指向返回的这个对象。
如果构造器显式地返回了一个 object 类型的对 象，那么此次运算结果终会返回这个对象，而不是我们之前期待的 this

    var MyClass = function() {
        this.name = 'sven';
        return { // 显式地返回一个对象         
            name: 'anne'
        }
    };
    var obj = new MyClass();
    alert(obj.name); // 输出：anne
如果构造器不显式地返回任何数据，或者是返回一个非对象类型的数据，就不会造成上述问题

**丢失的this**

    var obj = {
        myName: 'sven',
        getName: function() {
            return this.myName;
        }
    };
    console.log(obj.getName()); // 输出：'sven'  作为obj对象的属性被调用 
    var getName2 = obj.getName;
    console.log(getName2()); // 输出：undefined  普通函数调用方式，this指向全局window

###二，call和apply

ECAMScript 3给Function的原型定义了两个方法，它们是Function.prototype.call和Function. prototype.apply

**1）call和apply的区别**

作用一模 一样，区别仅在于传入参数形式的不同

- apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下 标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传 递给被调用的函数： 

'

    var func = function(a, b, c) {
        alert([a, b, c]); // 输出 [ 1, 2, 3 ] };  
        func.apply(null, [1, 2, 3]);
    }

- call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向， 从第二个参数开始往后，每个参数被依次传入函数： 

'

    var func = function(a, b, c) {
        alert([a, b, c]); // 输出 [ 1, 2, 3 ] };  
        func.call(null, 1, 2, 3);
    }

，apply 比 call 的使用 率更高，我们不必关心具体有多少参数被传入函数，只要用 apply 一股脑地推过去就可以了
当使用 call 或者 apply 的时候，如果我们传入的第一个参数为 null，函数体内的 this 会指 向默认的宿主对象，在浏览器中则是 window

    var func = function(a, b, c) {
        alert(this === window); // 输出 true 
    };
    func.apply(null, [1, 2, 3]);

有时候我们使用 call 或者 apply 的目的不在于指定 this 指向，而是另有用途，比如借用其 他对象的方法。那么我们可以传入 null 来代替某个具体的对象： 

    Math.max.apply( null, [ 1, 2, 5, 3, 4 ] )    // 输出：5 

**2）call和apply的用途**

- 改变this指向

例1：

    var obj1 = {
        name: 'sven'
    };
    var obj2 = {
        name: 'anne'
    };
    window.name = 'window';
    var getName = function() {
        alert(this.name);
    };
    getName(); // 输出: window 
    getName.call( obj1 );    // 输出: sven 
    getName.call( obj2 );    // 输出: anne
例：修正func函数内的this

    document.getElementById('div1').onclick = function() {
        alert(this.id); // 输出：div1     
        var func = function() {
            alert(this.id); // 输出：undefined     
        }
        func();
    };
    //修正后
    document.getElementById('div1').onclick = function() {
        var func = function() {
            alert(this.id); // 输出：div1     
        }
        func.call(this);
    };
    //
    var getId = function(id) {
        return document.getElementById(id);
    };
    getId('div1');

    // document.getElementById 方法的内部实现中需要用到 this。这个 this 本来被期望指向 document，
    //当 getElementById 方法作为 document 对象的属性被调用时，方法内部的 this 确实是指 向 document 的。 但当用 getId 来引用 document.getElementById 之后，再调用 getId，此时就成了普通函数调用， 函数内部的 this 指向了 window，而不是原来的 document
    //修正后
    document.getElementById = (function(func) {
        return function() {
            return func.apply(document, arguments);
        }
    })(document.getElementById);
    var getId = document.getElementById;
    var div = getId('div1');
    alert(div.id); // 输出： div1

- Function.prototype.bind

大部分高级浏览器都实现了内置的Function.prototype.bind，用来指定函数内部的this指向， 即使没有原生的 Function.prototype.bind 实现,我们来模拟一个也不是难事，代码如下

    Function.prototype.bind = function(context) {
        var self = this; // 保存原函数
        return function() { // 返回一个新的函数
            return self.apply(context, arguments); // 执行新的函数的时候，会把之前传入的 context
            // 当作新函数体内的 this
        }
    };
    var obj = {
        name: 'sven'
    };
    var func = function() {
        alert(this.name); // 输出：sven
    }.bind(obj);
    func();
在 Function.prototype.bind 的内部实现中，我们先把 func 函数的引用保存起来，然后返回一 个新的函数。当我们在将来执行 func 函数时，实际上先执行的是这个刚刚返回的新函数。在新 函数内部，self.apply( context, arguments )这句代码才是执行原来的 func 函数，并且指定 context 对象为 func 函数体内的 this。 

这是一个简化版的 Function.prototype.bind 实现，通常我们还会把它实现得稍微复杂一点， 使得可以往 func 函数中预先填入一些参数： 

    Function.prototype.bind = function() {
        var self = this, // 保存原函数         
            context = [].shift.call(arguments), // 需要绑定的 this 上下文         
            args = [].slice.call(arguments); // 剩余的参数转成数组     
        return function() { // 返回一个新的函数         
            return self.apply(context, [].concat.call(args, [].slice.call(arguments)));
            // 执行新的函数的时候，会把之前传入的 context 当作新函数体内的 this             
            // 并且组合两次分别传入的参数，作为新函数的参数         
        }
    };
    var obj = {
        name: 'sven'
    };
    var func = function(a, b, c, d) {
        alert(this.name); // 输出：sven     
        alert([a, b, c, d]) // 输出：[ 1, 2, 3, 4 ] 
    }.bind(obj, 1, 2);
    func(3, 4);

- 借用其他对象的方法

借用方法的第一种场景是“借用构造函数”，通过这种技术，可以实现一些类似继承的效果

    var A = function(name) {
        this.name = name;
    };
    var B = function() {
        A.apply(this, arguments);
    };
    B.prototype.getName = function() {
        return this.name;
    };
    var b = new B('sven');
    console.log(b.getName()); // 输出： 'sven'
借用方法的第二种运用场景跟我们的关系更加密切。
比如想往 arguments 中添加一个新的元素，通常会借用 Array.prototype.push： 

    (function() {
        Array.prototype.push.call(arguments, 3);
        console.log(arguments); // 输出[1,2,3] 
    })(1, 2);
在操作 arguments 的时候，我们经常非常频繁地找 Array.prototype 对象借用方法。 想把 arguments 转成真正的数组的时候，可以借用 Array.prototype.slice 方法；想截去 arguments 列表中的头一个元素时，又可以借用 Array.prototype.shift 方法。
借用 Array.prototype.push 方法的对 象还要满足以下两个条件：
 
 - 对象本身要可以存取属性； 
 - 对象的 length 属性可读写。 

'

    var a = {};
    Array.prototype.push.call(a, 'first');
    alert(a.length); // 输出：1 
    alert(a[0]); // first

    // 不满足条件1
    var a = 1;
    Array.prototype.push.call(a, 'first');
    alert(a.length); // 输出：undefined 
    alert(a[0]); // 输出：undefined

    // 不满足条件2
    var func = function() {};
    Array.prototype.push.call(func, 'first');
    alert(func.length); // 报错：cannot assign to read only property ‘length’ of function(){}
