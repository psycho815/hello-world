#this、call和apply
###一，this
this的指向大致分为4种：

- 作为对象的方法调用 (this指向该对象)
- 作为普通函数调用 （ this指向全局对象，即window）②
- 构造器调用 ③
- Function.prototype.call 或 Function.prototype.apply 调用（动态改变传入函数的this）

②如在 div 节点的事件函数内部，有一个局部的 callback 方法， callback 被作为普通函数调用时，callback 内部的 this 指向了 window，但我们往往是想让它指向 该 div 节点。
有一种简单的解决方案，可以用一个变量保存 div 节点的引用： 

    document.getElementById('div1').onclick = function() {
        var that = this; // 保存 div 的引用     
        var callback = function() {
            alert(that.id); // 输出：'div1'     
        }
        callback();
    };

③当用 new 运算符调用函数时，该函数总 会返回一个对象，通常情况下，构造器里的 this 就指向返回的这个对象。
如果构造器显式地返回了一个 object 类型的对 象，那么此次运算结果终会返回这个对象，而不是我们之前期待的 this

    var MyClass = function() {
        this.name = 'sven';
        return { // 显式地返回一个对象         
            name: 'anne'
        }
    };
    var obj = new MyClass();
    alert(obj.name); // 输出：anne
如果构造器不显式地返回任何数据，或者是返回一个非对象类型的数据，就不会造成上述问题

**丢失的this**

    var obj = {
        myName: 'sven',
        getName: function() {
            return this.myName;
        }
    };
    console.log(obj.getName()); // 输出：'sven'  作为obj对象的属性被调用 
    var getName2 = obj.getName;
    console.log(getName2()); // 输出：undefined  普通函数调用方式，this指向全局window

###二，call和apply

